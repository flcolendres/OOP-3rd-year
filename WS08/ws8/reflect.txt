// Francis Lloyd Colendres
// OOP345 Workshop 8
// November 17, 2022

In this workshop, I tested my knowledge in raw pointers and smart pointers. This workshop is quite easy because the allocation of the raw pointer is similar to the smart pointers. Smart pointers are advantageous compared to raw pointers because it handles the deallocation process which prevents any memory leaks. In my code, for example,  the writeRaw() function consists of raw pointers. There are conditions that need to be met before adding an employee to the list: its salary has to been within range, and the SIN has to be valid. If none of the conditions are 
met, an exception is thrown. Unfortunately, the moment that an exception is thrown, the dynamically all does not get deallocated. One solution is to delete the pointer in certain parts of the writeRaw() function. I basically deallocated the pointer in various parts of the code. This was slightly confusing for me because I was getting memory leak error for not deallocating the object. Therefore, the downside of raw pointers in this function is that they need to be manually deallocated. This can lead to some memory leak if I did not deallocate in a certain part of the writeRaw() function. 
Smart pointers are different from raw pointers syntactically. The (*) symbol is used when implementing a pointer. For smart pointers, I could use either std::unique_ptr or std::shared_ptr.
The syntax for smart pointers, in my case, took some time to get used to because I keep forgetting the proper keywords. Smart pointers are still advantageous despite of its hard-to-remember syntax. The writeSmart() function had the same purpose as writeRaw() except the writeSmart() uses smart pointers. Based on my observation, the writeSmart() was shorter because it did not have the extra step of manually deallocating the object. At first I used shared_ptr in my writeSmart() function instead of the unique_ptr because the program won't allow me to pass the pointer by value. I just realized it makes sense because the moment that I pass the unique_ptr by value, it will deallocate the moment it goes out of scope. However, I realized that it would not be necessary to use shared_ptr because I could pass the unique_ptr by reference so I can refer to its values in another function.
To conclude, smart pointers provide less stress to programmers such as myself because it handles the deallocation of the object. I will try to use it more often in my future programs.