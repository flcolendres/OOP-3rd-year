/*
* Francis Lloyd Colendres
* flcolendres@myseneca.ca
* 145498200
* Oct. 09, 2022
* I have done all the coding by myself and only copied the code that
* my professor provided to complete my workshops and assignments.
*/
In this workshop, I applied my knowledge in functions and error handling. I also discovered the use of observer functions which allows me to call different functions from the templated class to a client method. My observer function demonstrates a function pointer because it points to the address of a function, which was the client function. I was able to handle errors in my program to prevent it from stopping while it was running.       
The "T& operator[](size_t idx) const" in my program determines whether the given index was out of range. I was able to throw an exception of type out_of_range with a message. I learned that the program will have a run-time error if the error was thrown, but not caught. I learned that an error should be thrown within a try-catch block and the thrown error must match a certain catch condition. I also realized that I could pass a string to an exception's parameter and refer to it within a catch block using the what() function. Functors are classes where function objects are instantiated and can overload a function call. Meanwhile lambda expressions are function objects used within a block. Lambda expressions are defined to a variable. I think both uses are dependent on the scope in which it is useful. For example, in the workshop, I created a variable with a lambda expression which converts the book's price to a certain currency rate depending on its country and year of publication. It makes sense to create a lambda expression in this scope because the Book object is found within the same scope. The constructor for SpellChecker generates an exception of "Bad file name!" if the file is missing. I solved this by checking if the filename is null and if so, it would throw a "Bad file name!" message and catch it with an exception of (const char*). I could achieve the same result by not throwing an exception and instead just print an output stream (cout << "Bad file name!"). Similarly, the operator[] generates an out_of_range exception if the index is out of range and print an error message. In this case, I can just print a message stating the index is out of range and return a nullptr. Since Movie and Book have an almost identical logic to loading data from a file, I would probably create a class called Entertainment. The attributes are based on the Book class since the Movie has the same attributes as the Book. I would add an attribute named m_type which determines whether the object is a Book or a Movie. 
The execution of the methods are determined by the m_type. I think that the Movie and Book classes should keep its default constructor because there will be cases in which objects are initialized without specific value. Therefore, they default constructors should be kept to ensure that the objects are set to safe empty states if the programmer ever creates an object without a specific value. A good example would be the movies object of type Movie with an array size of 5. Without a default constructor, it would not be possible to do this. 