// Francis Lloyd Colendres
// Workshop 9
// November 27, 2022
// OOP-345

In this workshop, I was instructed to read and write from a text file converted to binary file. There was an additional step on reading and writing with binary files. For non-binary files, I assign the text from the text file into a local string variable before assigning it to a member variable. If necessary, I would use built in string functions to convert the string to a member variable's data type before assigning it to a member variable. For binary files, the read and write converts the member variable's address into a char* (const char* for write function) and the size of the data type is given to determine how much data is assigned into the variable. Both are similar in a sense that the process may either throw an exception or logical error if the length of data type provided is more than the member variable's data type. The bind function assigns a function to a variable with the parameters provided. The bind function is useful in this workshop becausse it allows the programmer to have a pre determined result due to the given parameters. Furthermore, the bind function was necessary because the packaged_task needed a callable function in order to perform asynchronous tasks.
Multiple threads can perform a process at a much faster rate because they work concurrently to give the result. The workshop was confusing with multithreading because I was getting build errors and these errors were vague. I was having difficulties determining the proper syntax. However, after multiple attempts and tips given by my professor, I managed to make it work. Since the string pointer had twelve rows, I managed to break down the string into 4 separate string variables. Then, I bind the functions into a digForTreasure function with each string and the given char mark argument. The packaged_task was used to wrap each bound functions. Then, each packaged task is associated to a future before executing each packaged task into a thread. The results of the packaged tasks are accumulated to a local count function through the futures. Futures retrieve the values returned by packaged_task. Once the value is provided, the future becomes an active state. Finally, the threads are synchronized before returning the value of count.
	